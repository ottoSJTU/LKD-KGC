faq).
**why not stream protobuf messages?**
if you use persistent http/1.1 connections, they are pretty close to streaming. of course, headers have to be re-sent, but that is less expensive than a new tcp set up.
**why do we send samples in order?**
the in-order constraint comes from the encoding we use for time series data in prometheus, the implementation of which is optimized for append-only workloads. however, this requirement is also shared across many other databases and vendors in the ecosystem. in fact, [prometheus with ooo feature enabled](=1321), allows out-of-order writes, but with the performance penalty, thus reserved for rare events. to sum up, receivers may support out-of-order write, though it is not permitted by the specification. in the future e.g. 2.x spec versions, we could extend content type to negotiate the out-of-order writes, if needed.
**how can we parallelise requests with the in-order constraint?**
samples must be in-order _for a given series_. however, even if a receiver does not support out-of-order write, the remote-write requests can be sent in parallel as long as they are for different series. prometheus shards the samples by their labels into separate queues, and then writes happen sequentially in each queue. this guarantees samples for the same series are delivered in order, but samples for different series are sent in parallel - and potentially "out of order" between different series.
**what are the differences between remote-write 2.0 and opentelemetry's otlp protocol?**
[opentelemetry otlp]() is a protocol for transporting of telemetry data (such as metrics, logs, traces and profiles) between telemetry sources, intermediate nodes and telemetry backends. the recommended transport involves grpc with protobuf, but http with protobuf or json are also described. it was designed from scratch with the intent to support a variety of different observability signals, data types and extra information. for [metrics]() that means additional non-identifying labels, flags, temporal aggregations types, resource or scoped metrics, schema urls and more. otlp also requires [the semantic convention]() to be used.
remote-write was designed for simplicity, efficiency and organic growth. the first version was officially released in 2023, when already [dozens of battle-tested adopters in the cncf ecosystem](./remote_write_spec.md
compatible-senders-and-receivers) had been using this protocol for years. remote-write 2.0 iterates on the previous protocol by adding a few new elements (metadata, exemplars, created timestamp and native histograms) and string interning. remote-write 2.0 is always stateless, focuses only on metrics and is opinionated; as such it is scoped down to elements that the prometheus community considers enough to have a robust metric solution. the intention is to ensure the remote-write is a stable protocol that is cheaper and simpler to adopt and use than the alternatives in the observability ecosystem.